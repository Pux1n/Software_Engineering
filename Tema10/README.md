# Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнил:
- Белоусов Андрей Андреевич
- ПИЭ-21-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Наверняка вы думаете, что декораторы – это какая-то бесполезная<br>вещь, которая вам никогда не пригодится, но тут вдруг на паре по<br>математике преподаватель просит всех посчитать число Фибоначчи для<br>100. Кто-то будет считать вручную (так точно не нужно), кто-то<br>посчитает на калькуляторе, а кто-то подумает, что он самый крутой и<br>напишет рекурсивную программу на Python и немного огорчится,<br>потому что данная программа будет достаточно долго считаться, если<br>ее просто так запускать. Но именно тут к вам на помощь приходят<br>декораторы, например @lru_cache (он предназначен для решения задач<br>динамическим программированием, если простыми словами, то этот<br>декоратор запоминает промежуточные результаты и при рекурсивном<br>вызове функции программа не будет считать одни и те же значения, а<br>просто “возьмёт их из этого декоратора”). Вам нужно написать<br>программу, которая будет считать числа Фибоначчи для 100 и<br>запустить ее без этого декоратора и с ним, посмотреть на разницу во<br>времени решения поставленной задачи.<br>P.S. при запуске без декоратора можете долго не ждать, для<br>наглядности хватит 10 секунд ожидания.

```python
from functools import lru_cache


@lru_cache(None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)


if __name__ == '__main__':
    print(fibonacci(100))

```

### Результат.
![Меню](https://github.com/Pux1n/Software_Engineering/blob/Tema10/Tema10/pic/1.png)

## Лабораторная работа №2
### Илья пишет свой сайт и ему необходимо сделать минимальную<br>проверку ввода данных пользователя при регистрации. Для этого он<br>реализовал функцию, которая выводит данные пользователя на экран и<br>решил, что будет проверять правильность введённых данных при<br>помощи декоратора, но в этом ему потребовалась ваша помощь.<br>Напишите декоратор для функции, который будет принимать все<br>параметры вызываемой функции (имя, возраст) и проверять чтобы<br>возраст был больше 0 и меньше 130.<br>Причем заметьте, что неважно сколько пользователь введет данных на<br>сайт к Илье, будут обрабатываться только первые 2 аргумента

```python
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]

        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)

    return output_func


@check
def personal_info(name, age):
    print(f"Name: {name} Age: {age}")


if __name__ == '__main__':
    personal_info('Владимир', 38)
    personal_info('Александр', -5)
    personal_info('Петр', 138, 15, 48, 2)

```

### Результат.
![Меню](https://github.com/Pux1n/Software_Engineering/blob/Tema10/Tema10/pic/2.png)

## Лабораторная работа №3
### Вам понравилась идея Ильи с сайтом, и вы решили дальше работать<br>вместе с ним. Но вот в вашем проекте появилась проблема, кто-то<br>пытается сломать вашу функцию с получением данных для сайта. Эта<br>функция работает только с данными integer, а какой-то недохакер<br>пытается все сломать и вместо нужного типа данных отправляет string.<br>Воспользуйтесь исключениями, чтобы неподходящий тип данных не<br>ломал ваш сайт.<br>Также дополнительно можете обернуть весь код функции в<br>try/except/finally для того, чтобы программа вас оповестила о том, что<br>выявлена какая-то ошибка или программа успешно выполнена

```python
def data(*args):
    try:
        for i in range(len(*args)):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')


if __name__ == '__main__':
    data([1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45])
```

### Результат.
![Меню](https://github.com/Pux1n/Software_Engineering/blob/Tema10/Tema10/pic/3.png)

## Лабораторная работа №4
### Продолжая работу над сайтом, вы решили написать собственное<br>исключение, которое будет вызываться в случае, если в функцию<br>проверки имени при регистрации передана строка длиннее десяти<br>символов, а если имя имеет допустимую длину, то в консоль<br>выводиться “Успешная регистрация”

```python
class NegativeValueException(Exception):
    pass


def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
        print('Успешная регистрация')


if __name__ == '__main__':
    name = '12345678910'
    check_name(name)
```

### Результат.
![Меню](https://github.com/Pux1n/Software_Engineering/blob/Tema10/Tema10/pic/4.png)

## Лабораторная работа №5
### После запуска сайта вы поняли, что вам необходимо добавить логгер,<br>для отслеживания его работы. Готовыми вариантами вы не захотели<br>пользоваться, и поэтому решили создать очень простую пародию. Для<br>этого создали две функции: __init__() (вызывается при создании класса<br>декоратора в программе) и __call__() (вызывается при вызове<br>декоратора). Создайте необходимый вам декоратор. Выведите все логи<br>в консоль.

```python
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func = func

    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__)
        self.func()
        print('> Проверка безопасности выключения')


@SiteChecker
def site():
    print('Усердная работа сайта')


if __name__ == '__main__':
    print('>> Сайт запущен')
    site()
    print('>> Сайт выключен')
```

### Результат.
![Меню](https://github.com/Pux1n/Software_Engineering/blob/Tema10/Tema10/pic/5.png)


## Самостоятельная работа №1
### Вовочка решил заняться спортивным программированием на python, но<br>для этого он должен знать за какое время выполняется его программа.<br>Он решил, что для этого ему идеально подойдет декоратор для<br>функции, который будет выяснять за какое время выполняется та или<br>иная функция. Помогите Вовочке в его начинаниях и напишите такой<br>декоратор.<br>Результатом вашей работы будет листинг кода и скриншот консоли, в<br>котором будет выполненная функция Фибоначчи и время выполнения<br>программы

```python
import time


def time_of(func):
    def input_func():
        start_time = time.time()
        result = func()
        end_time = time.time()
        result_time = end_time - start_time
        print(f"\nВремя выполнения: {result_time} сек")
        return result
    return input_func


@time_of
def fibonacci():
    fib1 = fib2 = 1

    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end='')


if __name__ == '__main__':
    fibonacci()
```

### Результат.
![Меню](https://github.com/Pux1n/Software_Engineering/blob/Tema10/Tema10/pic/s1.png)

## Выводы

В данном коде импортируется модуль time,
Создается функция-декоратор time_of(), в которой с помощью модуля time выводится время работы обернутой функции.
Далее функция fibonacci(), которая выводит число Фибоначчи, обертывается в декоратор time_of(),
и во входной точке выполняется функция fibonacci() и выводится время ее выполнения.

## Самостоятельная работа №2
### Посмотрев на Вовочку, вы также загорелись идеей спортивного<br>программирования, начав тренировки вы узнали, что для решения<<br>некоторое время вы столкнулись с проблемой что файлы бывают<br>пустыми, и вы не получаете вводные данные для решения задачи.<br>После этого вы решили не просто считывать данные из файла, а всю<br>конструкцию оборачивать в исключения, чтобы избежать такой <br>проблемы. Создайте пустой файл и файл, в котором есть какая-то<br>информация. Напишите код программы. Если файл пустой, то, нужно<br>вызвать исключение (“бросить исключение”) и вывести в консоль<br>“файл пустой”, а если он не пустой, то вывести информацию из файла.

```python
import os


def print_file(file):
    with open(file) as f:
        if os.stat(file).st_size == 0:
            raise Exception(f"Файл '{file}' пустой")
        print(f.readline())


try:
    print_file('empty_file.txt')
except Exception as e:
    print(e)

try:
    print_file('not_empty_file.txt')
except Exception as e:
    print(e)
```

### Результат.
![Меню](https://github.com/Pux1n/Software_Engineering/blob/Tema10/Tema10/pic/s2.png)

## Выводы

В данном коде импортируется модуль os.
В функции print_file(), если размер входного файла равен нулю, то бросается исключение с сообщением, что файл пустой, если размер не равен нулю, то выводится первая строка файла.
Затем с помощью блоков try/except вызывается функция print_file() для пустого файла и для не пустого.
  
## Самостоятельная работа №3
### Напишите функцию, которая будет складывать 2 и введенное<br>пользователем число, но если пользователь введет строку или другой<br>неподходящий тип данных, то в консоль выведется ошибка<br>“Неподходящий тип данных. Ожидалось число.”. Реализовать<br>функционал программы необходимо через try/except и подобрать<br>правильный тип исключения. Создавать собственное исключение<br>нельзя. Проведите несколько тестов, в которых исключение вызывается<br>и нет. Результатом выполнения задачи будет листинг кода и<br>получившийся вывод в консоль

```python
def plus_two():
    try:
        b = int(input("Введите число, которое нужно сложить с 2: "))
        result = 2 + b
        return result
    except ValueError:
        print("Неподходящий тип данных. Ожидалось число.")


print(plus_two())
print(plus_two())
print(plus_two())
```

### Результат.
![Меню](https://github.com/Pux1n/Software_Engineering/blob/Tema10/Tema10/pic/s3.png)

## Выводы

В данном коде в функции plus_two() с помощью блока try/except введенное число проверяется на исключние ValueError, и, если исключение поймалось, выводится "Неподходящий тип данных. Ожидалось число.", или, если исключений нет, возвращается результат сложения.
  
## Самостоятельная работа №4
### Создайте собственный декоратор, который будет использоваться для<br>двух любых вами придуманных функций. Декораторы, которые<br>использовались ранее в работе нельзя воссоздавать. Результатом<br>выполнения задачи будет: класс декоратора, две как-то связанными с<br>ним функциями, скриншот консоли с выполненной программой и<br>подробные комментарии, которые будут описывать работу вашего кода.

```python
def half(func):
    def output_func(*args):
        result = func(*args) / 2
        return result
    return output_func


@half
def summ(*args):
    nums = args
    result = 0
    for num in nums:
        result += num
    return result


@half
def mult(*args):
    nums = args
    result = 1
    for num in nums:
        result *= num
    return result


print(summ(1, 2, 3, 4))
print(mult(1, 2, 3, 4))
```

### Результат.
![Меню](https://github.com/Pux1n/Software_Engineering/blob/Tema10/Tema10/pic/s4.png)

## Выводы

В данном коде в функции-декораторе half() возвращается результат обернутой функции деленный на 2.
В функции summ() возвращается сумма всех аргументов.
В функции mult() возвращается произведение всех аргументов.
Обе функции обернуты в half() и возвращают при вызове свое значение деленное на 2.
  
## Самостоятельная работа №5
### Создайте собственное исключение, которое будет использоваться в<br>двух любых фрагментах кода. Исключения, которые использовались<br>ранее в работе нельзя воссоздавать. Результатом выполнения задачи<br>будет: класс исключения, код к котором в двух местах используется это<br>исключение, скриншот консоли с выполненной программой и<br>подробные комментарии, которые будут описывать работу вашего кода.

```python
class NotIntError(Exception):
    def __init__(self, message='Ошибка: в аргументах функции введен не целочисленный параметр.'):
        self.message = message
        super().__init__(self.message)


def summ(*args):
    nums = args
    result = 0
    for num in nums:
        if isinstance(num, int):
            result += num
        else:
            raise NotIntError()
    return result


try:
    print(summ(1, 2, 3, 4))
except NotIntError as e:
    print(e)

try:
    print(summ(2, 4, 4, 'a', 'f'))
except NotIntError as e:
    print(e)
```

### Результат.
![Меню](https://github.com/Pux1n/Software_Engineering/blob/Tema10/Tema10/pic/s5.png)

## Выводы

В данном коде в классе-исключении NotIntError в конструкторе определяется сообщение ошибки.
В функции summ(), если не все введенные аргументы являются int, то бросается исключение NotIntError.
Затем с помощью try/except проводятся тесты функции summ(), и если в тесте найдено исключение NotIntError, то выводится его сообщение.

## Общие выводы по теме

В результате выполнения данной работы, я научился работать с декораторами и исключениями в Python.
